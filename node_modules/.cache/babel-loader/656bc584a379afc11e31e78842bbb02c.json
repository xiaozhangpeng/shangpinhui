{"remainingRequest":"C:\\Users\\Administrator\\Desktop\\上线项目\\app\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Administrator\\Desktop\\上线项目\\app\\src\\router\\index.js","dependencies":[{"path":"C:\\Users\\Administrator\\Desktop\\上线项目\\app\\src\\router\\index.js","mtime":1648192648360},{"path":"C:\\Users\\Administrator\\Desktop\\上线项目\\app\\babel.config.js","mtime":1648180147605},{"path":"C:\\Users\\Administrator\\Desktop\\上线项目\\app\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1647341553526},{"path":"C:\\Users\\Administrator\\Desktop\\上线项目\\app\\node_modules\\babel-loader\\lib\\index.js","mtime":1647341553791}],"contextDependencies":[],"result":["import \"core-js/modules/es6.function.name\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"C:/Users/Administrator/Desktop/\\u4E0A\\u7EBF\\u9879\\u76EE/app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es6.regexp.replace\";\n//配置路由的地方\nimport Vue from 'vue';\nimport Router from 'vue-router';\nimport store from \"@/store\"; //使用插件\n\nVue.use(Router); // 引入路由组件\n\nimport routes from \"./routes\"; //重写push方法\n//解决当多次传参相同时，程序报错的问题\n//先把Router原型对象的push方法重写一遍\n\nvar originPush = Router.prototype.push;\nvar originReplace = Router.prototype.replace; //重写push/replace\n//第一个参数，告诉原来push方法，你往哪里跳转（传递那些参数）\n//第二个参数，resolve成功的回调\n//第三个参数，reject失败的回调\n\nRouter.prototype.push = function (location, resolve, reject) {\n  // 第一种情况：resolve成功回调和reject失败回调同时回传\n  // console.log(this)\n  if (resolve && reject) {\n    //call|apply区别\n    //相同点：都可以调用函数一次，都可以篡改函数的上下文一次\n    //不同点：call和apply传递参数，call传递参数用逗号隔开，apply方法执行，传递数组\n    originPush.call(this, location, resolve, reject);\n  } // 第二中情况：除第一种的所有其他情况\n  else {\n    originPush.call(this, location, function () {}, function () {});\n  }\n}; // 重写replace方法\n\n\nRouter.prototype.replace = function replace(location, resolve, reject) {\n  if (reject && resolve) {\n    return originReplace.call(this, location, resolve, reject);\n  } else {\n    return originReplace.call(this, location, function () {}, function () {});\n  }\n}; //配置路由\n\n\nvar router = new Router({\n  // mode:'history',\n  // 注册路由组件\n  routes: routes,\n  // 滚动行为\n  scrollBehavior: function scrollBehavior(to, from, savedPosition) {\n    // 返回的这个y=0，代表的滚动条在最上方\n    // y=100表示距离顶部有100px\n    return {\n      y: 0\n    };\n  }\n}); //全局守卫：前置守卫（在路由跳转之前进行判断，前置守卫用到的多一些）\n\nrouter.beforeEach( /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(to, from, next) {\n    var token, name, toPath;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // 用户登陆了，才会有token\n            token = store.state.user.token; //用户信息\n\n            name = store.state.user.userInfo.name; // console.log(token);\n            // console.log(name)\n            // 用户已经登陆过了\n\n            if (!token) {\n              _context.next = 24;\n              break;\n            }\n\n            if (!(to.path == '/login' || to.path == '/register')) {\n              _context.next = 7;\n              break;\n            }\n\n            next('/');\n            _context.next = 22;\n            break;\n\n          case 7:\n            if (!name) {\n              _context.next = 11;\n              break;\n            }\n\n            // console.log(\"有name,正常放行\")\n            next();\n            _context.next = 22;\n            break;\n\n          case 11:\n            _context.prev = 11;\n            _context.next = 14;\n            return store.dispatch('getUserInfo');\n\n          case 14:\n            // console.log(\"没有name，请求数据\")\n            next();\n            _context.next = 22;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](11);\n            _context.next = 21;\n            return store.dispatch('userLogout');\n\n          case 21:\n            next('/login');\n\n          case 22:\n            _context.next = 27;\n            break;\n\n          case 24:\n            toPath = to.path; // 未登录，不能去交易相关[trade],不能去支付相关[pay/paysuccess],不能去个人中心[center]\n            // 未登录的只能去登录界面  indexOf('/trade')==-1的含义是不包含trade字段 而indexOf('/trade')!=-1含义是包含trade字段 --反反为正\n            // 使用indexOf可以一举两得,把包含目标字段的所有路由全部概括\n\n            if (to.path.indexOf('/trade') != -1 || to.path.indexOf('/pay') != -1 || to.path.indexOf('/center') != -1) {\n              next('/login?redirect=' + toPath); //解决的是:当用户未登录的情况下点击我的订单,在跳转登录页面并登录完成之后,可以直接跳转到我的订单页面,而不是首页\n            } // 去的不是上面这些路由(home|search|shopCart)--放行\n\n\n            next();\n\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[11, 17]]);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}());\nexport default router;",{"version":3,"sources":["C:/Users/Administrator/Desktop/上线项目/app/src/router/index.js"],"names":["Vue","Router","store","use","routes","originPush","prototype","push","originReplace","replace","location","resolve","reject","call","router","scrollBehavior","to","from","savedPosition","y","beforeEach","next","token","state","user","name","userInfo","path","dispatch","toPath","indexOf"],"mappings":"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","sourcesContent":["//配置路由的地方\r\nimport Vue from 'vue'\r\nimport Router from 'vue-router'\r\n\r\nimport store from \"@/store\"\r\n\r\n\r\n//使用插件\r\nVue.use(Router)\r\n\r\n// 引入路由组件\r\nimport routes from \"./routes\"\r\n\r\n\r\n//重写push方法\r\n//解决当多次传参相同时，程序报错的问题\r\n//先把Router原型对象的push方法重写一遍\r\nlet originPush = Router.prototype.push;\r\n\r\nlet originReplace = Router.prototype.replace;\r\n\r\n//重写push/replace\r\n//第一个参数，告诉原来push方法，你往哪里跳转（传递那些参数）\r\n//第二个参数，resolve成功的回调\r\n//第三个参数，reject失败的回调\r\nRouter.prototype.push = function(location, resolve, reject) {\r\n    // 第一种情况：resolve成功回调和reject失败回调同时回传\r\n    // console.log(this)\r\n    if (resolve && reject) {\r\n        //call|apply区别\r\n        //相同点：都可以调用函数一次，都可以篡改函数的上下文一次\r\n        //不同点：call和apply传递参数，call传递参数用逗号隔开，apply方法执行，传递数组\r\n        originPush.call(this, location, resolve, reject);\r\n    }\r\n    // 第二中情况：除第一种的所有其他情况\r\n    else {\r\n        originPush.call(this, location, () => {}, () => {})\r\n\r\n    }\r\n}\r\n\r\n// 重写replace方法\r\nRouter.prototype.replace = function replace(location, resolve, reject) {\r\n    if (reject && resolve) {\r\n        return originReplace.call(this, location, resolve, reject);\r\n    } else {\r\n        return originReplace.call(this, location, () => {}, () => {})\r\n    }\r\n}\r\n\r\n\r\n//配置路由\r\nlet router = new Router({\r\n    // mode:'history',\r\n\r\n    // 注册路由组件\r\n    routes,\r\n    // 滚动行为\r\n    scrollBehavior(to, from, savedPosition) {\r\n        // 返回的这个y=0，代表的滚动条在最上方\r\n        // y=100表示距离顶部有100px\r\n        return { y: 0 }\r\n    }\r\n});\r\n\r\n//全局守卫：前置守卫（在路由跳转之前进行判断，前置守卫用到的多一些）\r\nrouter.beforeEach(async(to, from, next) => {\r\n\r\n    // 用户登陆了，才会有token\r\n    let token = store.state.user.token;\r\n    //用户信息\r\n    let name = store.state.user.userInfo.name;\r\n    // console.log(token);\r\n    // console.log(name)\r\n    // 用户已经登陆过了\r\n    if (token) {\r\n        // 用户已经登陆了，就不能去login登录页面，只能停留在首页\r\n        if (to.path == '/login' || to.path == '/register') {\r\n            next('/')\r\n        } else {\r\n            // 登录，并且去的不是login[可能是home/search等]\r\n            // 如果name有，正常放行\r\n            if (name) {\r\n                // console.log(\"有name,正常放行\")\r\n                next();\r\n            } else {\r\n                try\r\n                // 如果没有na   me,需要派发action让仓库存储用户信息在跳转\r\n                {\r\n                    // 当用户刷新的时候，name丢失需要重新派发请求数据\r\n                    await store.dispatch('getUserInfo');\r\n                    // console.log(\"没有name，请求数据\")\r\n                    next()\r\n                } catch (error) {\r\n                    //token失效了,获取不到用户的信息，需要重新登录\r\n                    //清除token\r\n                    await store.dispatch('userLogout');\r\n                    next('/login');\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n    // 用户还没有登录\r\n    else {\r\n        let toPath = to.path;\r\n        // 未登录，不能去交易相关[trade],不能去支付相关[pay/paysuccess],不能去个人中心[center]\r\n        // 未登录的只能去登录界面  indexOf('/trade')==-1的含义是不包含trade字段 而indexOf('/trade')!=-1含义是包含trade字段 --反反为正\r\n        // 使用indexOf可以一举两得,把包含目标字段的所有路由全部概括\r\n        if (to.path.indexOf('/trade') != -1 || to.path.indexOf('/pay') != -1 || to.path.indexOf('/center') != -1) {\r\n            next('/login?redirect=' + toPath); //解决的是:当用户未登录的情况下点击我的订单,在跳转登录页面并登录完成之后,可以直接跳转到我的订单页面,而不是首页\r\n        }\r\n        // 去的不是上面这些路由(home|search|shopCart)--放行\r\n        next()\r\n    }\r\n\r\n});\r\n\r\nexport default router;"]}]}